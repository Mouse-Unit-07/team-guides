# Clean Code Concepts
Modern philosophies of writing clean code.

## Index
- [The Boy Scout Rule](#the-boy-scout-rule)
- [Naming](#naming)
- [Comments](#comments)
- [Formatting](#formatting)
- [Objects and Data Structures](#objects-and-data-structures)
- [Error handling](#error-handling)
- [Boundaries](#boundaries)
- [Other Miscellaneous Code Smells](#other-miscellaneous-code-smells)

## The Boy Scout Rule
  - Leave the campground cleaner than you found it
  - Code rots when you don't consciously think about maintenance
  - To prevent code from degrading over time, it’s our duty to make code cleaner than the way we found it

## Naming
  - intention revealing names
    - Take time to choose an identifier name (function, variables, classes, etc) that reveal the single purpose of the thing you’re creating
    - Long identifiers are perfectly fine if it’s necessary
    - Short identifiers are even better if they do just as well to pinpoint exactly what the identifier is for
  - avoid disinformation
    - Don’t leave misleading hints for programmers
      - if a variable is an array and not a list, don’t name it accountList
    - Don’t accumulate a collection of identifiers that differ in small ways
      - thisIsAReallyLongVariableName
      - thisIsAPrettyLongVariableName
    - lower case l’s and O’s
      - hard to distinguish between 1/0 and the conventional i/j
  - make meaningful distinctions
    - meaningless names
      - arguments a1, a2, etc for a function signature don’t tell you anything
      - don’t just satisfy the compiler
    - noise words
      - noise words are words that programmers will ignore- eliminate them
      - “variable”/”var” in a variable name is redundant
      - “data”/”info” in a class or struct don’t mean anything, and fail to distinguish one another
      - “string” for a string or “int” for an integer doesn’t add any meaning- focus on conveying the logical sequence and purpose of operations instead of implementation details
      - “ethernet” in front of all fields/attributes/methods in an “ethernet” class/struct doesn’t add any meaning, and it’s a lazy way of adding a distinguisher to your interface
    - pronounceable names
      - We can’t physically talk about code if things aren’t pronounceable
    - searchable names
      - Use single-letter names only for local variables inside short functions
      - Take time to come up w/ a unique identifier to avoid any overlap 
    - encodings
      - If it needs extra explanation because only you or a set of individuals know what a set of letters mean, then it’s encoded- unravel the encoding
  - Interfaces and implementations
    - If there’s an interface / abstract class / abstract data type, and it’s difficult to come up w/ a name to differentiate the interface and implementation, give the implementation the additional encoding/extension
  - Eliminate "hungarian notation"
    - It’s an outdated concept from when programming languages limited identifier name lengths
    - don’t add to identifier names to indicate scope, class association, etc
    - p_ for pointers, g_ for globals, m_ for class fields, etc
  - avoid mental mapping
    - readers shouldn’t have to map your identifiers to concepts or other names to understand your code
    - chugging out a function w/ 10 different single letter variables doesn’t make you smart- it’s ugly code
  - class names (structs for C)
    - should be noun or noun phrases
    - avoid generic terms like “manager”, “processor”, “data”, etc
  - method names
    - should have verb/verb phrase names
    - accessors, mutators, and predicates should be prefixed w/ “get”, “set”, “is” following the javabean standard
  - don’t be cute
    - you’re asking for people to be confused when you add inside jokes or references that only certain people will understand to identifier names
  - pick one word per concept
    - “fetch”, “retrieve”, and “get” in the same codebase or file or class is confusing-choose a verb/noun for a particular concept and stick w/ it
    - be descriptive enough to be distinguishable in a codebase, and unique and concise enough to be distinguishable in an implementation file
    - Don’t rely on IDE provided hints for function signatures- name items to be descriptive enough on their own
    - Don’t hide differences- if a codebase has an “add” function for adding/concatenating two values, don’t create an “add” function that appends an item to an array
  - solution domain names
    - Programmers read code, so we’re free to use CS terms, algorithm names, pattern names, math terms, etc as need be
    - Remember that we also want to convey purpose and functionality over implementation details
  - Problem domain names
    - If there’s no generic or “programmer-eese” lingo to describe a concept, choose a problem specific name- it’s better than a naked noise word 
  - Add meaningful context
    - Some words are descriptive and indicate context on their own, but most aren’t
    - If you have a class or struct storing physical user addresses, then “state” can be used together w/ “zipcode” or “streetNumber”, but “state” on its own isn’t descriptive- don’t make users ever have to infer the concept based on a vague name
Functions
  - Small
    - “The first rule of functions is that they should be small. The second rule of functions is that they should be smaller than that”
    - This is for readability, testing, scalability, modularity
      - Short functions w/ consistent level of abstraction across the function is easy to read and build upon
      - It’s impossible to write a test for long functions- there are too many states and paths engraved into it
      - It’s easy to add features when implementation details are abstracted atomically by purpose
      - Short functions divided by purpose (writing modular code) allows for easy modification, replacement, and addition
  - Blocks and indenting
    - The contents of a compound statement created by an “if”, “while”, “else” statement should ideally consist of just a single statement- that statement should be a function call
    - The indent level of a function should not be greater than 1 or 2
    - This adds readability, because it forces writers to choose descriptive and concise identifiers for helper functions as well
  - Do one thing
    - “functions should do one thing. They should do it well. They should do it only.”
    - Single responsibility principle
  - One level of abstraction per function
    - A function shouldn’t both perform a bitwise operation on a variable and perform a high-level send function- the bitwise operation should be abstracted into a helper function to match levels of abstraction
    - This aids readability, and enforces additional modularity
  - Reading code from top to bottom: the stepdown rule
    - Code should read like a narrative- top level of abstraction down to all of its sub abstractions down to lowest level operations
  - Switch statements
    - Switch statements and long if-else chains are used to do more than 1 thing- this goes against single responsibility principle, and open-close principle if the set of processes needs be added to when adding additional features
    - Collapse the operation down to smaller functions if applicable
    - If you’re really dealing w/ a single static operation describable and controlled best by a single switch statement, then all is good
  - Use descriptive names
    - “you know you are working on clean code when each routine turns out to be pretty much what you expected”
    - The function name needs to encapsulate the entirety of the one thing it does- there shouldn’t be undescribed side effects or processing- don’t hesitate to make the function name longer to describe the one thing that the function does concisely
  - Function arguments
    - Ideally, functions have niladic (zero) arguments
    - Then what’s tolerable is:
      - monadic (1 argument)
      - dyadic (2 arguments)
      - triadic (3 arguments) on special cases
      - there needs to be an outlier justification for anything more than that (and then that outlier function shouldn’t ever be used…)
    - Functions should take inputs, and return outputs- output arguments are hard to understand, and add unnecessary clutter when we can divide the work to more helper functions instead
    - Functions shouldn’t take Boolean/flag arguments- the function signature confesses that it does multiple things (one thing if flag, another if !flag)
    - Write a unit test for a triadic is already impossible- try to minimize the number of arguments into a function everywhere
    - Monadic
      - Monadic functions that don’t classify as one of the below can be collapsed to niladic form:
        - Asking a question about an argument
        - Operating on an argument / transforming it, and returning it
        - Event- take in a particular event as an argument and modify the state of the system
    - Dyadic
      - Used when there are two components to a single conceptual input
        - Point p = new Point(0, 1)
      - Come up w/ ways to reduce dyadic to monadic
        - writeField(output-stream, name) ->
          - make writeField a member function of output-stream class
          - make output-stream a member variable of the class 
          - extract a new class to take output-stream in a constructor 
      - dyadic functions are hard to interpret
        - ordering of arguments
        - comprehending argument purpose
        - may cause readers to ignore arguments
    - Triadic
      - Problems of a dyadic are scaled more than double when you have a triadic
      - There needs to be an exceptional reason to generate a triadic… 
      - If there needs to be that many arguments to encapsulate a single conceptual input, then generate a new class or struct and take that as an input instead
        - This isn’t cheating- testability is maintained while enhancing readability
    - Ellipsis and argument lists
      - A list of arguments (a collection of arguments passed to a print function) can be considered a single argument
    - Descriptive function names continued
      - Function names can be made descriptive to specify how arguments are being used, and to indicate whether order matters
      - Write(name)
        - Writing “name” to what? What’s “writing”?
        - writeField(name) is better
      - assert(expected, actual)
        - does order matter? What’s being compared to what?
        - assertExpectedEqualsActual(expected, actual) is better
  - side effects
    - side effects are lies
    - your function promises to do one thing as per function name, but it does other hidden things
    - refactor and rename to follow single responsibility principle
  - command query separation
    - functions should either do something or answer something, not both
    - aka, don’t return status
    - a function should either modify the state of an object, or return information about an object- doing both leads to confusion, and goes against single responsibility principle
    - if (set(“username”, “john doe”))
      - does this set something and return status, or check whether something is just set?
      - Can’t tell
  - Error handling
    - Error handling is one thing
    - Functions should do one thing- create an independent function for error handling
    - Use exceptions instead of returning error codes if applicable to programming language- lets you follow single responsibility principle
    - Enumeration of error codes
      - It’s a dependency magnet
      - Other files need to be aware of the error codes, forcing coupling between files far and wide
      - Goes against open-close principle- users can’t add error codes without rebuilding an entire project
  - Don’t repeat yourself
    - DRY
    - As mentioned before in TDD section
  - Structured programming
    - Dijkstra says that “every function, and every block within a function, should have one entry and one exit”
      - This implies one return, no break or continue statements in loops, no goto statements
      - These rules provide benefit for larger functions- there’s less merit from following these rules for small functions
      - Jump statements are horrible on all fronts, but if there needs to be a break, continue, or multiple returns then go ahead
## Comments
  - “the proper use of comments is to compensate for our failure to express ourself in code. Note that I used the word failure. I meant it” – Robert C. Martin 
  - Comments (including obligatory Javadoc comments) demand maintaining, become lies when they’re not maintained, and invite doubt to begin with
  - Explain yourself through concise and descriptive naming
  - Good comments
    - Legal comments
      - Copyrights, etc- no way around it
    - Informative comments
      - Do this if there’s absolutely no way for the code itself to explain the context- so when there’s a need to explain why something exists
      - Providing basic information with a comment (kept concise and descriptive as possible) is fine, provided above
    - Explanation of intent
      - If there’s a design decision that can only be explained by elaborating on a piece of code (abstractions and descriptive names aren’t enough), then comments are valid
    - Clarification
      - Obscure arguments and return values can be clarified if need be (a function name can beautifully describe the one thing it does, but fail to describe what it returns or takes in without the full function signature)
      - The issue again is that clarifications can lie or mislead- minimize at all costs and be concise
    - Warning of consequences
      - Consequences of changing an implementation to something that would appear to be more efficient but not, a warning that a function takes a long time to run, etc
    - Todo comments
      - TODOs are jobs that the programmer thinks should be done, but for some reason can’t do at the moment- it’s not an excuse to leave bad code in the system
    - Amplification 
      - If there are processes or decisions that seem inconsequential, a comment can be written to highlight it
    - Javadocs
      - Write them if you absolutely have to- so if you’re writing a public API
      - Otherwise the maintenance isn’t worth it for the little benefit of having a bunch of documentation that should otherwise be inherit in your code that should already be explaining itself
  - Bad comments
    - Mumbling
      - Don’t talk to yourself through comments
      - If only you can interpret it, remove it or rewrite it
    - Redundant comments
      - Don’t rewrite what the code already explains on its own
    - Misleading comments
      - Comments that explain what’s being done tend to be wrong and misleading in subtle ways- don’t write them, just write why things are done if need be
    - Mandated comments
      - Javadocs are silly if they’re mandated for no reason
      - They clutter code, and create potential for lies and misdirection
    - Journal comments
      - Revision history, log messages, etc
      - That’s what version control is for- don’t add them
    - Noise comments
      - Don’t state the obvious 
      - Most common for mandated javadocs
      - Noise turns into scary noise when you accidentally write in lies
    - Add variables and functions instead of comments
      - Variables encapsulate expressions into concepts, and functions encapsulate a series of processes into concepts
    - Position markers
      - Comments that are used to mark a particular position in a source file are fine, but they should be used sparingly
      - The less there are, the more they stand out, and the less users will ignore them and consider them noise
      - When there are too many, they’re all translated to noise
    - Closing brace comments
      - Often used to indicate what each closing brace is for
      - Write shorter functions instead
    - Attributions and bylines
      - Authors, etc
      - That’s what version control is for- don’t add them
    - Commented-out code
      - Horrible- they exist to rot, never to be uncommented
      - Delete them all- they’ll be saved in source control
    - HTML and multiple languages
      - Minimize the number of languages in a single source file- we’re already working w/ English + source code language by default
      - Don’t force unnecessary context switching on the reader
    - Nonlocal information
      - If a comment must be written, don’t add information about code elsewhere- comments are associated w/ where they’re written
    - Too much information
      - Don’t add unnecessary background information
    - Unobvious connection
      - Readers shouldn’t have to think about how your comments map to the code- make the connection as obvious as possible
    - Function headers
      - Functions should describe themselves- this eliminates the need for both function headers and javadocs
## Formatting
  - Vertical formatting
    - File size
      - Complex systems can be created w/ a bunch of small files- 200 lines min to 500 lines max
      - Smaller files are easier to read than longer files
    - Newspaper metaphor
      - At the top is the headline- you can decide whether to keep reading or not
      - As you continue downward, the details increase
    - Vertical openness between concepts
      - Each blank line is a visual cue that identifies a new and separate concept
    - Vertical density
      - Lines of code that are tightly related should appear vertically dense
      - Useless comments break the close association between variables, blocks of code, etc
    - Vertical distance
      - Concepts that are closely related should exist close to each other, and in the same source file 
      - There should be a good reason for separating related concepts into different files
      - Variable declaration 
        - Should be as close to their usage as possible
        - w/ short functions, all variables should appear at the top of each function
      - Instance variables
        - Should be declared at the top of the class
        - The “scissors rule” might be applied in C++, placing instance variables at the bottom of the class
      - Dependent functions
        - If one function calls another, they should be vertically close and the caller should be above the callee if possible
      - Conceptual affinity
        - Certain bits of code want to be near other bits- this could be because of direct dependence, or maybe because the functions perform similar operations, etc
        - Group code that feel like they should be grouped together vertically close together
      - Vertical ordering
        - Function call dependencies should point in a downward direction only
        - Function called should be below those that call them
        - In C/C++ you can’t avoid function prototypes of helper private static functions- unavoidable, but keep the definitions below callers
  - Horizontal formatting
    - 80 character rule
      - The old 80 characters per line is pretty arbitrary- 100 to 120 is tolerable, but after that is just carelessness
      - Monitors are large now, and you can see a lot even without scrolling to the right, but if you’re making the font smaller on your text editor to view your code then you need to make some changes
    - Horizontal openness and density
      - Use horizontal whitespaces to associate things that are strongly related, and disassociate things that aren’t
    - Horizontal alignment
      - Don’t add extra whitespaces to align variable names, assignments, etc
      - This invites the reader to read just particular columns of text, and forces readers to go back and forth
      - The jagged lists won’t be a problem, if the lists are short
    - Indentation
      - Indentation aid readability- don’t remove them
      - Don’t collapse the indentation for short blocks of code (if statements, short while loops, etc)
    - Dummy scopes
      - While and for statement blocks should be surrounded by braces and properly indented 
      - A semicolon on the same line as the while loop expression is confusing- at the very least, the semicolon should be on its own line w/ indentation
    - Team rules
      - Don’t mix individual styles- agree on a single coding standard

## Objects and Data Structures
  - Data abstraction
    - Don’t expose details of abstract data types and interfaces through committed setter and getter names
  - Data/object anti-symmetry
    - Objects and data structures are opposites- don’t mix and match
    - It’s a myth that everything is an object- sometimes you do want simple data structures w/ procedures operating on them
    - Objects
      - Objects hide their data behind abstractions and expose functions that operate on that data (functions are generic, and written w/ signatures to allow subclasses to be written to inherit templates)
      - OO code makes it easy to add new classes without changing existing functions
      - OO code makes it hard to add new functions because all the classes must change
    - Data structures
      - Data structures expose their data and have no meaningful functions (if there are functions, the data structure’s attributes are baked into the operations rather than performing abstract operations to follow and allow for polymorphism)
      - Procedural code makes it easy to add new functions without changing the existing data structures
      - Procedural code makes it hard to add new data structures since all functions must change
  - The law of Demeter
    - A module should not know about the innards of the object it manipulates
    - Aka, object shouldn’t expose its internal structure through accessors because doing so would be to expose internal structure
    - This means that a method f of class C should only call methods of these:
      - C
      - An object created by f
      - An object passed as an argument of f
      - An object held in an instance variable of C
    - A method of a class shouldn’t call the method of an object generated by the object passed as an argument to it, or the method of the instance variable of an instance variable of it
    - Following this rule maintains modularity and boundaries between modules- otherwise it’s no longer a “module”
    - This rule doesn’t apply to data structures- only objects/modules have the intent of hiding their innards
  - Train wrecks 
    - Chains of calls are sloppy
    - Store the return value of calls into variables instead
      - This doesn’t bypass law of Demeter- decoupling train wrecks aren’t an excuse to let modules manipulate and expose the innards of other modules
  - Hybrids
    - Don’t create object / data structure hybrids
    - The purpose of creating an abstract module/object is defeated if there are public accessor functions that expose the innards of the object, making it look like a data structure that has abstract functions
  - Data transfer objects
    - An ideal data structure just has public variables and no functions- these are called DTOs (“data transfer objects”)
    - Used for communicating w/ databases, parsing messages from sockets, etc
    - An object w/ a collection of private variables and accessors/setters to all of them is a data structure- just expose the member variables
    - Active record
      - A DTO w/ navigational methods like “save” and “find” are active records
      - Don’t add business rule methods- this creates hybrids

## Error handling
  - Refer to TDD section for more on error handling in C
  - Java
    - The objective is to separate error handling from business logic:
    - Use exceptions rather than return codes
      - Removes clutter by removing need for caller to check for errors after a function call
    - Write try-catch-finally statement first
      - The first try-catch-finally block defines the scopes for you to work in- write this try-catch-finally block first in response to each exception w/ TDD, and then you can work your way down
    - Use unchecked exceptions
      - This allows you to follow open-close principle
      - You don’t want a low level change to cause changes all the way up where errors are handled
  - Define the normal flow
    - You can bypass the need for an exception / error by using the “special case pattern”
      - if you have a function that would return an error code in response to a particular situation, you can define an output for such special cases instead of spitting out an error
  - don’t return null
    - horrible- generates work for callers
  - don’t pass null
    - horrible- generates work for callees

## Boundaries
  - there’s an inherit tension between the provider of an interface and the user of an interface
  - you want to minimize the work for the users of an interface- if you define an abstract interface / template, then the concrete implementations that inherit the interface should do the work of defining functions that cast abstract types to the appropriate types
  - third party code
    - learn the third party code by writing tests one by one and verifying behavior
  - using code that doesn’t exist yet
    - write provided what you wish you had

## Other Miscellaneous Code Smells
  - build requires more than one step
    - building a project should be a single operation
    - shouldn’t be checking out a bunch of little pieces from source code control, no sequence of arcane commands or context dependent scripts to build individual elements, no searching for JARs, XML files, or other artifacts
  - tests require more than one step
    - running all tests should be a single operation
  - dead functions
    - functions that aren’t ever called should be removed
  - incorrect behavior at boundaries
    - don’t rely on intuition
    - look for every boundary condition and write a test for it
    - it’s how that iPod freeze issue could’ve been avoided
    - and how all other software related RMAs could be avoided
  - overridden safeties
    - Chernobyl melted down because the plant manager overrode each safety mechanism one by one- they were in the way of running an experiment
    - Don’t turn off compiler warnings, don’t turn off failing tests
  - Follow standard conventions
    - Every team should follow a coding standard based on common industry norms
    - There shouldn’t be a document- examples should speak for themselves
    - Every team member must be mature enough to realize it doesn’t matter where you put your braces as long as you all agree on where to put them
  - Structure over compliance
    - Enforce design decision w/ structure over convention
    - Switch cases w/ nicely named enumerations are inferior to base classes w/ abstract methods, etc
  - Avoid negative conditionals
    - When encapsulating conditional expressions, it’s easier to read if the encapsulations aren’t negative
    - Do this:
      - If (buffer.shouldCompact())
    - Over this:
      - If (!buffer.shouldNotCompact())
  - Hidden temporal couplings
    - Structure functions to make it obvious the way in which functions need to be called
    - By forcing functions to generate results required for other functions to run, it forces a particular function order
    - Extra syntactic complexity is demanded in exchange for exposing true temporal complexity
  - Don’t be arbitrary
    - Have a reason for the way code is structured, and make sure the reason is communicated through the code- if structure looks arbitrary, others will feel empowered to change it
  - Encapsulate boundary conditions
    - Adding a simple variable is enough to encapsulate +1s and -1s in conditional expressions
  - Keep configurable data at high levels
    - Constants like default or configuration values that are known and expected shouldn’t be buried in low-level functions
    - Expose such data as arguments to the low-level functions from high-level functions
  - Tests
    - Insufficient tests
      - A test suite should test everything that could possibly break
      - Tests are insufficient for as long as there are conditions that haven’t been explored by the tests
    - Use a coverage tool
      - Tools like Clover (Java only) can report gaps in a testing strategy
    - Don’t skip trivial tests
      - They’re easy to write- just write them
      - Documentary value is higher than cost to write them
    - An ignored test is a question about an ambiguity
      - Readers question whether the ambiguity is about something that compiles or not
    - Exhaustively test near bugs
      - If there’s one bug, there are likely more
    - Tests should be fast
      - Slow tests don’t get run
      - Do what you must to keep tests fast



## Others
add new items here